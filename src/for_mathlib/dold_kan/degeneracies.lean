/-
Copyright (c) 2022 JoÃ«l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: JoÃ«l Riou
-/

import for_mathlib.dold_kan.decomposition
import tactic.fin_cases
import for_mathlib.split_simplicial_object

/-!

# Behaviour of P_infty with respect to degeneracies

For any `X : simplicial_object C` where `C` is an abelian category,
the projector `P_infty : K[X] âŸ¶ K[X]` is supposed to be the projection
on the normalized subcomplex, parallel to the degenerate subcomplex, i.e.
the subcomplex generated by the images of all `X.Ïƒ i`.

In this file, we obtain `P_infty_on_degeneracies` which states that
if `X : simplicial_object C` with `C` a preadditive,
`Î¸ : [n] âŸ¶ Î”'` is a non injective map in `simplex_category`, then
`X.map Î¸.op â‰« P_infty.f n = 0`. It follows from the more precise
statement `Ïƒ_comp_P_eq_zero` which is obtained for the `P q`
by induction on `q : â„•`.

-/

noncomputable theory

namespace category_theory
namespace simplicial_object

variables {C : Type*} [category C]

@[reassoc]
lemma Î´_comp_Ïƒ_succ' (X : simplicial_object C) {n : â„•} {i : fin (n+1)} {j : fin (n+2)}
  (h : j = i.succ) : X.Ïƒ i â‰« X.Î´ j = ğŸ™ _ :=
by { subst h, rw X.Î´_comp_Ïƒ_succ, }

local attribute [reassoc] Î´_comp_Ïƒ_self
local attribute [reassoc] Î´_comp_Ïƒ_succ
local attribute [reassoc] Ïƒ_comp_Ïƒ

end simplicial_object
end category_theory

open category_theory category_theory.category category_theory.limits category_theory.idempotents
  category_theory.preadditive opposite
open_locale simplicial dold_kan

namespace algebraic_topology

namespace dold_kan

variables {C : Type*} [category C] [preadditive C]

lemma higher_faces_vanish.comp_Ïƒ {Y : C} {X : simplicial_object C} {n b q : â„•} {Ï† : Y âŸ¶ X _[n+1]}
  (v : higher_faces_vanish q Ï†) (hnbq : n + 1 = b + q) :
    higher_faces_vanish q (Ï† â‰« X.Ïƒ âŸ¨b,
    by simpa only [hnbq, nat.lt_succ_iff, le_add_iff_nonneg_right] using zero_le qâŸ©) := Î» j hjâ‚,
begin
  rw assoc,
  have eq := simplicial_object.Î´_comp_Ïƒ_of_gt X (_ : fin.cast_succ âŸ¨b, _âŸ© < j), rotate,
  { rw [hnbq, lt_add_iff_pos_right],
    by_contradiction,
    simp only [not_lt, nonpos_iff_eq_zero] at h,
    rw [h, add_zero] at hjâ‚,
    have pif := lt_of_le_of_lt hjâ‚ (fin.is_lt j),
    simpa only [lt_self_iff_false] using lt_of_le_of_lt hjâ‚ (fin.is_lt j), },
  { rw [fin.cast_succ_mk, fin.lt_iff_coe_lt_coe, fin.coe_mk, nat.lt_iff_add_one_le,
      â† add_le_add_iff_right q, add_assoc, add_comm 1, â† add_assoc, â† hnbq],
    exact hjâ‚, },
  simp only [fin.cast_succ_mk] at eq,
  have hjâ‚‚ : j â‰  0,
  { intro hjâ‚ƒ,
    simpa only [hjâ‚ƒ, hnbq, fin.coe_zero, zero_add, add_comm b, add_assoc, add_le_iff_nonpos_right,
      le_zero_iff, add_eq_zero_iff, nat.one_ne_zero, false_and] using hjâ‚, },
  rw [eq, â† assoc],
  conv_lhs { congr, congr, skip, rw â† fin.succ_pred j hjâ‚‚, },
  rw [v (j.pred hjâ‚‚), zero_comp],
  rw [â† add_le_add_iff_right 1, add_assoc _ q, add_comm q 1, â† add_assoc,
      â† fin.coe_succ, fin.succ_pred],
  exact hjâ‚,
end

lemma Ïƒ_comp_P_eq_zero (X : simplicial_object C)
  {n q : â„•} : âˆ€ (i : fin (n + 1)) (hi : n + 1 â‰¤ i + q),
  (X.Ïƒ i) â‰« (P q).f (n + 1) = 0 :=
begin
  induction q with q hq,
  { intros i hi,
    exfalso,
    have h := fin.is_lt i,
    linarith, },
  { intros i hi,
    by_cases n+1 â‰¤ (i : â„•)+q,
    { unfold P,
      simp only [homological_complex.comp_f, â† assoc],
      rw [hq i h, zero_comp], },
    { have hi' : n = (i : â„•) + q,
      { cases le_iff_exists_add.mp hi with j hj,
        rw [â† nat.lt_succ_iff, nat.succ_eq_add_one, add_assoc, hj, not_lt,
          add_le_iff_nonpos_right, nonpos_iff_eq_zero] at h,
        rw [â† add_left_inj 1, add_assoc, hj, self_eq_add_right, h], },
      cases n,
      { fin_cases i,
        rw [show q = 0, by linarith],
        unfold P,
        simp only [id_comp, homological_complex.add_f_apply, comp_add, homological_complex.id_f],
        erw [comp_id, HÏƒ, homotopy.null_homotopic_map'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl)],
        unfold hÏƒ' hÏƒ,
        simp only [nat.not_lt_zero, if_false, tsub_zero, pow_zero, pow_one, one_zsmul,
          neg_smul, comp_add, neg_comp, comp_neg, eq_to_hom_refl,comp_id,
          alternating_face_map_complex.obj_d_eq],
        dsimp,
        erw [fin.sum_univ_two, fin.sum_univ_succ, fin.sum_univ_two],
        simp only [fin.coe_zero, pow_zero, one_zsmul, fin.coe_one, pow_one, neg_smul,
          add_comp, neg_comp, comp_add, comp_neg, neg_add_rev, neg_neg, â† add_assoc,
          fin.succ_zero_eq_one, fin.succ_one_eq_two, fin.coe_two, neg_one_sq],
        have simplif : âˆ€ (a b c d e f : X _[0] âŸ¶ X _[1]), a = b â†’ a = c â†’ a = d â†’ a = e â†’
          a = f â†’ a + b + (-c) + (-d) + e  + (-f) = 0,
        { intros a b c d e f hb hc hd he hf,
          rw [â† hb, â† hc, â† hd, â† he, â† hf],
          abel, },
        apply simplif,
        { erw simplicial_object.Î´_comp_Ïƒ_self_assoc, },
        { erw simplicial_object.Î´_comp_Ïƒ_succ_assoc, },
        { erw [simplicial_object.Î´_comp_Ïƒ_succ, comp_id], },
        { erw [simplicial_object.Î´_comp_Ïƒ_self, comp_id], },
        { erw simplicial_object.Î´_comp_Ïƒ_of_le X
            (show (0 : fin(2)) â‰¤ fin.cast_succ 0, by rw fin.cast_succ_zero),
          erw simplicial_object.Î´_comp_Ïƒ_self_assoc, }, },
      { rw [â† id_comp (X.Ïƒ i), â† (P_add_Q_f q n.succ : _ = ğŸ™ (X.obj _)), add_comp, add_comp,
          â† zero_add (0 : X.obj (op [n+1]) âŸ¶ X.obj (op [n+2]))],
        congr,
        { have v : higher_faces_vanish q ((P q).f n.succ â‰« X.Ïƒ i) :=
            (higher_faces_vanish.of_P q n).comp_Ïƒ hi',
          unfold P,
          erw [â† assoc, v.comp_P_eq_self, homological_complex.add_f_apply,
            preadditive.comp_add, comp_id, v.comp_HÏƒ_eq hi', add_neg_eq_zero, assoc],
          rw simplicial_object.Î´_comp_Ïƒ_succ'_assoc, swap,
          { ext,
            simp only [fin.coe_mk, fin.coe_succ], },
          refl, },
        { simp only [decomposition_Q n q, preadditive.sum_comp],
          apply finset.sum_eq_zero,
          intros j hj,
          simp only [true_and, finset.mem_univ, finset.mem_filter] at hj,
          let i' : fin (n + 1) := âŸ¨(i : â„•), _âŸ©, swap,
          { by_contradiction h',
            simp only [not_lt] at h',
            simp only [nat.succ_eq_add_one] at hi',
            rw hi' at h',
            simp only [add_le_iff_nonpos_right, nonpos_iff_eq_zero] at h',
            rw h' at hj,
            exact nat.not_lt_zero _ hj, },
          obtain âŸ¨k, hkâŸ© := nat.le.dest (nat.lt_succ_iff.mp (fin.is_lt j)),
          rw add_comm at hk,
          rw [show i = fin.cast_succ i', by { ext, simp only [fin.cast_succ_mk, fin.eta], },
            assoc, assoc, assoc, simplicial_object.Ïƒ_comp_Ïƒ_assoc], swap,
          { simp only [reverse_fin_eq j hk.symm, fin.le_iff_coe_le_coe, fin.coe_mk],
            simp only [nat.succ_eq_add_one] at hi',
            linarith, },
          unfold P,
          have eq' := hq (reverse_fin j).succ _, swap,
          { simp only [â† hk, reverse_fin_eq j hk.symm, nat.succ_eq_add_one,
              fin.succ_mk, fin.coe_mk],
            linarith, },
          simp only [assoc, homological_complex.comp_f, reassoc_of eq', zero_comp, comp_zero], }, }, }, },
end

lemma Ïƒ_comp_P_infty (X : simplicial_object C)
  {n : â„•} (i : fin (n+1)) :
  (X.Ïƒ i) â‰« P_infty.f (n+1) = 0 :=
begin
  rw P_infty_f,
  apply Ïƒ_comp_P_eq_zero X i,
  simp only [zero_le, le_add_iff_nonneg_left],
end

@[reassoc]
lemma P_infty_on_degeneracies (X : simplicial_object C)
  (n : â„•) {Î”' : simplex_category} (Î¸ : [n] âŸ¶ Î”')
  (hÎ¸ : Â¬mono Î¸) :
  X.map Î¸.op â‰« P_infty.f n = 0 :=
begin
  rw simplex_category.mono_iff_injective at hÎ¸,
  cases n,
  { exfalso,
    apply hÎ¸,
    intros x y h,
    fin_cases x,
    fin_cases y, },
  { rcases simplex_category.eq_Ïƒ_comp_of_not_injective Î¸ hÎ¸ with âŸ¨i, Î±, hâŸ©,
    rw [h, op_comp, X.map_comp, assoc, (show X.map (simplex_category.Ïƒ i).op = X.Ïƒ i, by refl),
      Ïƒ_comp_P_infty, comp_zero], },
end

end dold_kan

end algebraic_topology
