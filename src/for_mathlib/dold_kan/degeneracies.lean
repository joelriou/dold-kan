/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/

import for_mathlib.dold_kan.decomposition
import tactic.fin_cases
import algebraic_topology.split_simplicial_object

/-!

# Behaviour of P_infty with respect to degeneracies

For any `X : simplicial_object C` where `C` is an abelian category,
the projector `P_infty : K[X] ‚ü∂ K[X]` is supposed to be the projection
on the normalized subcomplex, parallel to the degenerate subcomplex, i.e.
the subcomplex generated by the images of all `X.œÉ i`.

In this file, we obtain `degeneracy_comp_P_infty` which states that
if `X : simplicial_object C` with `C` a preadditive,
`Œ∏ : [n] ‚ü∂ Œî'` is a non injective map in `simplex_category`, then
`X.map Œ∏.op ‚â´ P_infty.f n = 0`. It follows from the more precise
statement `œÉ_comp_P_eq_zero` which is obtained for the `P q`
by induction on `q : ‚Ñï`.

-/

noncomputable theory

open category_theory category_theory.category category_theory.limits category_theory.idempotents
  category_theory.preadditive opposite
open_locale simplicial dold_kan

namespace algebraic_topology

namespace dold_kan

variables {C : Type*} [category C] [preadditive C]

lemma higher_faces_vanish.comp_œÉ {Y : C} {X : simplicial_object C} {n b q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n+1]}
  (v : higher_faces_vanish q œÜ) (hnbq : n + 1 = b + q) :
    higher_faces_vanish q (œÜ ‚â´ X.œÉ ‚ü®b,
    by simpa only [hnbq, nat.lt_succ_iff, le_add_iff_nonneg_right] using zero_le q‚ü©) := Œª j hj‚ÇÅ,
begin
  rw assoc,
  have eq := simplicial_object.Œ¥_comp_œÉ_of_gt X (_ : fin.cast_succ ‚ü®b, _‚ü© < j), rotate,
  { rw [hnbq, lt_add_iff_pos_right],
    by_contradiction,
    simp only [not_lt, nonpos_iff_eq_zero] at h,
    rw [h, add_zero] at hj‚ÇÅ,
    simpa only [lt_self_iff_false] using lt_of_le_of_lt hj‚ÇÅ (fin.is_lt j), },
  { rw [fin.cast_succ_mk, fin.lt_iff_coe_lt_coe, fin.coe_mk, nat.lt_iff_add_one_le,
      ‚Üê add_le_add_iff_right q, add_assoc, add_comm 1, ‚Üê add_assoc, ‚Üê hnbq],
    exact hj‚ÇÅ, },
  simp only [fin.cast_succ_mk] at eq,
  have hj‚ÇÇ : j ‚â† 0,
  { intro hj‚ÇÉ,
    simpa only [hj‚ÇÉ, hnbq, fin.coe_zero, zero_add, add_comm b, add_assoc, add_le_iff_nonpos_right,
      le_zero_iff, add_eq_zero_iff, nat.one_ne_zero, false_and] using hj‚ÇÅ, },
  rw [eq, ‚Üê assoc],
  conv_lhs { congr, congr, skip, rw ‚Üê fin.succ_pred j hj‚ÇÇ, },
  rw [v (j.pred hj‚ÇÇ), zero_comp],
  rw [‚Üê add_le_add_iff_right 1, add_assoc _ q, add_comm q 1, ‚Üê add_assoc,
      ‚Üê fin.coe_succ, fin.succ_pred],
  exact hj‚ÇÅ,
end

lemma œÉ_comp_P_eq_zero (X : simplicial_object C)
  {n q : ‚Ñï} : ‚àÄ (i : fin (n + 1)) (hi : n + 1 ‚â§ i + q),
  (X.œÉ i) ‚â´ (P q).f (n + 1) = 0 :=
begin
  induction q with q hq,
  { intros i hi,
    exfalso,
    have h := fin.is_lt i,
    linarith, },
  { intros i hi,
    by_cases n+1 ‚â§ (i : ‚Ñï)+q,
    { unfold P,
      simp only [homological_complex.comp_f, ‚Üê assoc],
      rw [hq i h, zero_comp], },
    { have hi' : n = (i : ‚Ñï) + q,
      { cases le_iff_exists_add.mp hi with j hj,
        rw [‚Üê nat.lt_succ_iff, nat.succ_eq_add_one, add_assoc, hj, not_lt,
          add_le_iff_nonpos_right, nonpos_iff_eq_zero] at h,
        rw [‚Üê add_left_inj 1, add_assoc, hj, self_eq_add_right, h], },
      cases n,
      { fin_cases i,
        rw [show q = 0, by linarith],
        unfold P,
        simp only [id_comp, homological_complex.add_f_apply, comp_add, homological_complex.id_f],
        erw [comp_id, HœÉ, homotopy.null_homotopic_map'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl)],
        unfold hœÉ' hœÉ,
        simp only [nat.not_lt_zero, if_false, tsub_zero, pow_zero, pow_one, one_zsmul,
          neg_smul, comp_add, neg_comp, comp_neg, eq_to_hom_refl,comp_id,
          alternating_face_map_complex.obj_d_eq],
        dsimp,
        erw [fin.sum_univ_two, fin.sum_univ_succ, fin.sum_univ_two],
        simp only [fin.coe_zero, pow_zero, one_zsmul, fin.coe_one, pow_one, neg_smul,
          add_comp, neg_comp, comp_add, comp_neg, neg_add_rev, neg_neg, ‚Üê add_assoc,
          fin.succ_zero_eq_one, fin.succ_one_eq_two, fin.coe_two, neg_one_sq],
        have simplif : ‚àÄ (a b c d e f : X _[0] ‚ü∂ X _[1]), a = b ‚Üí a = c ‚Üí a = d ‚Üí a = e ‚Üí
          a = f ‚Üí a + b + (-c) + (-d) + e  + (-f) = 0,
        { intros a b c d e f hb hc hd he hf,
          rw [‚Üê hb, ‚Üê hc, ‚Üê hd, ‚Üê he, ‚Üê hf],
          abel, },
        apply simplif,
        { erw simplicial_object.Œ¥_comp_œÉ_self_assoc, },
        { erw simplicial_object.Œ¥_comp_œÉ_succ_assoc, },
        { erw [simplicial_object.Œ¥_comp_œÉ_succ, comp_id], },
        { erw [simplicial_object.Œ¥_comp_œÉ_self, comp_id], },
        { erw simplicial_object.Œ¥_comp_œÉ_of_le X
            (show (0 : fin(2)) ‚â§ fin.cast_succ 0, by rw fin.cast_succ_zero),
          erw simplicial_object.Œ¥_comp_œÉ_self_assoc, }, },
      { rw [‚Üê id_comp (X.œÉ i), ‚Üê (P_add_Q_f q n.succ : _ = ùüô (X.obj _)), add_comp, add_comp,
          ‚Üê zero_add (0 : X.obj (op [n+1]) ‚ü∂ X.obj (op [n+2]))],
        congr,
        { have v : higher_faces_vanish q ((P q).f n.succ ‚â´ X.œÉ i) :=
            (higher_faces_vanish.of_P q n).comp_œÉ hi',
          unfold P,
          erw [‚Üê assoc, v.comp_P_eq_self, homological_complex.add_f_apply,
            preadditive.comp_add, comp_id, v.comp_HœÉ_eq hi', add_neg_eq_zero, assoc],
          rw simplicial_object.Œ¥_comp_œÉ_succ'_assoc, swap,
          { ext,
            simp only [fin.coe_mk, fin.coe_succ], },
          refl, },
        { simp only [decomposition_Q n q, preadditive.sum_comp],
          apply finset.sum_eq_zero,
          intros j hj,
          simp only [true_and, finset.mem_univ, finset.mem_filter] at hj,
          let i' : fin (n + 1) := ‚ü®(i : ‚Ñï), _‚ü©, swap,
          { by_contradiction h',
            simp only [not_lt] at h',
            simp only [nat.succ_eq_add_one] at hi',
            rw hi' at h',
            simp only [add_le_iff_nonpos_right, nonpos_iff_eq_zero] at h',
            rw h' at hj,
            exact nat.not_lt_zero _ hj, },
          obtain ‚ü®k, hk‚ü© := nat.le.dest (nat.lt_succ_iff.mp (fin.is_lt j)),
          rw add_comm at hk,
          rw [show i = fin.cast_succ i', by { ext, simp only [fin.cast_succ_mk, fin.eta], },
            assoc, assoc, assoc, simplicial_object.œÉ_comp_œÉ_assoc], swap,
          { simp only [reverse_fin_eq j hk.symm, fin.le_iff_coe_le_coe, fin.coe_mk],
            simp only [nat.succ_eq_add_one] at hi',
            linarith, },
          unfold P,
          have eq' := hq (reverse_fin j).succ _, swap,
          { simp only [‚Üê hk, reverse_fin_eq j hk.symm, nat.succ_eq_add_one,
              fin.succ_mk, fin.coe_mk],
            linarith, },
          simp only [assoc, homological_complex.comp_f, reassoc_of eq', zero_comp, comp_zero], }, }, }, },
end

lemma œÉ_comp_P_infty (X : simplicial_object C)
  {n : ‚Ñï} (i : fin (n+1)) :
  (X.œÉ i) ‚â´ P_infty.f (n+1) = 0 :=
begin
  rw P_infty_f,
  apply œÉ_comp_P_eq_zero X i,
  simp only [zero_le, le_add_iff_nonneg_left],
end

@[reassoc]
lemma degeneracy_comp_P_infty (X : simplicial_object C)
  (n : ‚Ñï) {Œî' : simplex_category} (Œ∏ : [n] ‚ü∂ Œî')
  (hŒ∏ : ¬¨mono Œ∏) :
  X.map Œ∏.op ‚â´ P_infty.f n = 0 :=
begin
  rw simplex_category.mono_iff_injective at hŒ∏,
  cases n,
  { exfalso,
    apply hŒ∏,
    intros x y h,
    fin_cases x,
    fin_cases y, },
  { rcases simplex_category.eq_œÉ_comp_of_not_injective Œ∏ hŒ∏ with ‚ü®i, Œ±, h‚ü©,
    rw [h, op_comp, X.map_comp, assoc, (show X.map (simplex_category.œÉ i).op = X.œÉ i, by refl),
      œÉ_comp_P_infty, comp_zero], },
end

end dold_kan

end algebraic_topology
