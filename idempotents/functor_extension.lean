/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/

import category_theory.idempotents.karoubi
--import category_theory.functor_ext

noncomputable theory

open category_theory.category
open category_theory.idempotents.karoubi


namespace category_theory

lemma congr_obj {D D' : Type*} [category D] [category D'] {F G : D ‚•§ D'}
(h : F = G) : ‚àÄ X : D, F.obj X = G.obj X :=
by { intro X, rw h, }

lemma congr_map {D D' : Type*} [category D] [category D'] (F : D ‚•§ D')
{X Y : D} {f g : X ‚ü∂ Y} (h : f = g) : F.map f = F.map g :=
by { subst h, }

namespace idempotents

variables (C D : Type*) [category C] [category D]

@[simps]
def functor_extension : (C ‚•§ karoubi D) ‚•§ (karoubi C ‚•§ karoubi D) :=
{ obj := Œª F,
  { obj := Œª P, ‚ü®(F.obj P.X).X, (F.map P.p).f, begin
      have h := congr_arg (Œª (f : P.X ‚ü∂ P.X), F.map f) P.idempotence,
      simpa only [F.map_comp, hom_ext] using h,
    end‚ü©,
    map := Œª P Q f, ‚ü®(F.map f.f).f, begin
      have h := congr_arg (Œª (f : P.X ‚ü∂ Q.X), F.map f) f.comm,
      simpa only [F.map_comp, hom_ext] using h,
    end‚ü©, },
  map := Œª F G œÜ,
  { app := Œª P,
    { f := (F.map P.p).f ‚â´ (œÜ.app P.X).f,
      comm := begin
        dsimp,
        have h := hom_ext.mp (œÜ.naturality P.p),
        have h' := hom_ext.mp (congr_map F P.idempotence),
        simp only [functor.map_comp, comp] at h h',
        slice_rhs 3 4 { erw ‚Üê h },
        slice_rhs 1 3 { erw [h', h'], },
      end, },
    naturality' := Œª P Q f, begin
      ext,
      dsimp,
      have h := hom_ext.mp (œÜ.naturality f.f),
      have h' := hom_ext.mp (congr_map F (comp_p f)),
      have h'' := hom_ext.mp (congr_map F (p_comp f)),
      simp only [functor.map_comp, comp] at ‚ä¢ h h' h'',
      slice_rhs 2 3 { rw ‚Üê h, },
      slice_lhs 1 2 { rw h', },
      slice_rhs 1 2 { rw h'', },
    end },
  map_id' := Œª F, by { ext P, exact comp_p (F.map P.p), },
  map_comp' := Œª F G H œÜ œÜ', begin
    ext P,
    dsimp,
    simp only [comp],
    have h := hom_ext.mp (œÜ.naturality P.p),
    simp only [comp] at h,
    slice_rhs 2 3 { rw ‚Üê h, },
    conv { to_lhs, congr, rw ‚Üê P.idempotence, },
    simp only [functor.map_comp, comp, assoc],
  end, }

lemma functor_extension_comp_whiskering_left_to_karoubi :
  functor_extension C D ‚ãô (whiskering_left C (karoubi C) (karoubi D)).obj (to_karoubi C) = ùü≠ _ :=
begin
  apply functor.ext,
  { intros F G œÜ,
    ext X,
    dsimp,
    simp only [functor.map_id, id_eq, eq_to_hom_f, eq_to_hom_refl, comp_id,
      functor_extension_obj_obj_p, to_karoubi_obj_p, eq_to_hom_app, comp],
    rw [F.map_id X, id_eq, comp_p (œÜ.app X)], },
  { intro F,
    apply functor.ext,
    { intros X Y f,
      ext,
      dsimp,
      simp only [eq_to_hom_f, eq_to_hom_refl, comp_id, functor_extension_obj_obj_p,
        to_karoubi_obj_p, comp],
      erw [F.map_id, id_eq],
      exact (F.map f).comm, },
    { intro X,
      ext,
      { dsimp,
        rw [id_comp, comp_id, F.map_id, id_eq], },
      { refl, }, }, }
end

instance : faithful (functor_extension C D) := ‚ü®Œª F G œÜ‚ÇÅ œÜ‚ÇÇ, begin
  intro h,
  ext X,
  have h' := hom_ext.mp (congr_app h (((to_karoubi C).obj X))),
  dsimp at h',
  simpa only [functor.map_id, id_eq, p_comp] using h',
end‚ü©

variables {C} {D}
lemma nat_trans_eq {F G : karoubi C ‚•§ D} (œÜ : F ‚ü∂ G) (P : karoubi C) :
  œÜ.app P = F.map (decomp_id_i P) ‚â´ œÜ.app P.X ‚â´ G.map (decomp_id_p P) :=
begin
  rw [‚Üê œÜ.naturality, ‚Üê assoc, ‚Üê F.map_comp],
  conv { to_lhs, rw [‚Üê id_comp (œÜ.app P), ‚Üê F.map_id], },
  congr,
  apply decomp_id,
end

lemma nat_trans_eq' {F G : karoubi C ‚•§ D} (œÜ : F ‚ü∂ G) (P : karoubi C) :
  œÜ.app P = F.map (decomp_id_i P) ‚â´ œÜ.app ((to_karoubi C).obj P.X) ‚â´ G.map (decomp_id_p P) :=
by { rw [nat_trans_eq], refl, }

instance : full (functor_extension C D) :=
{ preimage := Œª F G œà, begin
    let œÜ' := functor.map ((whiskering_left C (karoubi C) (karoubi D)).obj (to_karoubi C)) œà,
    have eq : ‚àÄ (H : C ‚•§ karoubi D), _ = H :=
      congr_obj (functor_extension_comp_whiskering_left_to_karoubi C D),
    exact eq_to_hom (eq F).symm ‚â´ œÜ' ‚â´ eq_to_hom (eq G),
  end,
  witness' := Œª F G œà, begin
    ext P,
    dsimp,
    simp only [eq_to_hom_f, functor_extension_obj_obj_p, to_karoubi_obj_p, eq_to_hom_refl,
      comp_id, eq_to_hom_app, comp, nat_trans_eq' œà P, G.map_id P.X, id_eq],
    dsimp,
    have h := p_comp (œà.app ((to_karoubi C).obj P.X)),
    have h' := œà.naturality ((to_karoubi C).map P.p),
    have h'' := comp_p (G.map P.p),
    have h''' := congr_map G P.idempotence,
    dsimp at h,
    simp only [functor.map_id, id_eq, functor_extension_obj_map_f, to_karoubi_map_f, comp,
      hom_ext, functor.map_comp] at h h' h'' h''',
    slice_lhs 2 3 { erw h, },
    slice_lhs 1 2 { erw h', },
    slice_rhs 1 2 { erw h', },
    slice_lhs 2 3 { erw h'', },
    slice_rhs 2 3 { erw h''', },
  end }

variables (C) (D)

@[simps]
def functor_extension' : (C ‚•§ D) ‚•§ (karoubi C ‚•§ karoubi D) :=
(whiskering_right C D (karoubi D)).obj (to_karoubi D) ‚ãô functor_extension C D

lemma functor.assoc {E F : Type*} [category E] [category F] (œÜ : C ‚•§ D)
  (œÜ' : D ‚•§ E) (œÜ'' : E ‚•§ F) : (œÜ ‚ãô œÜ') ‚ãô œÜ'' = œÜ ‚ãô (œÜ' ‚ãô œÜ'') :=
by refl

lemma functor_extension'_comp_whiskering_left_to_karoubi :
  functor_extension' C D ‚ãô
    (whiskering_left C (karoubi C) (karoubi D)).obj (to_karoubi C) =
  (whiskering_right C _ _).obj (to_karoubi D) :=
by simp only [functor_extension', functor.assoc,
  functor_extension_comp_whiskering_left_to_karoubi, functor.comp_id]

#exit

@[simps]
def functor_extension'' [is_idempotent_complete D] :
  (C ‚•§ D) ‚•§ (karoubi C ‚•§ D) :=
functor_extension' C D ‚ãô (whiskering_right (karoubi C) (karoubi D) D).obj
    (to_karoubi_is_equivalence D).inverse


#exit

@[simps]
def functor_extension (F : C ‚•§ D) : karoubi C ‚•§ karoubi D :=
{ obj := Œª P, ‚ü®F.obj P.X, F.map P.p,
    by { rw ‚Üê F.map_comp, congr, exact P.idempotence, }‚ü©,
  map := Œª P Q f, ‚ü®F.map f.f,
    by { simp only [‚Üê F.map_comp], congr, exact f.comm, }‚ü©, }

@[simps]
def functor_extension' (F : C ‚•§ karoubi D) : karoubi C ‚•§ karoubi D :=
{ obj := Œª P, ‚ü®(F.obj P.X).X, (F.map P.p).1, begin
    have h := congr_arg (Œª (f : P.X ‚ü∂ P.X), F.map f) P.idempotence,
    simpa only [F.map_comp, hom_ext] using h,
  end‚ü©,
  map := Œª P Q f, ‚ü®(F.map f.f).f, begin
    have h := congr_arg (Œª (f : P.X ‚ü∂ Q.X), F.map f) f.comm,
    simpa only [F.map_comp, hom_ext] using h,
  end‚ü©, }

lemma functor_extension_eq (F : C ‚•§ D) :
  functor_extension F = functor_extension' (F ‚ãô to_karoubi D) :=
begin
  apply functor.ext,
  { intros P Q f,
    ext,
    simpa only [functor_extension'_obj_p, functor_extension'_map_f,
      functor_extension_map_f, functor.comp_map, comp, id_eq,
      functor_extension_obj_p, eq_to_hom_refl, to_karoubi_map_f,
      F.map_comp] using congr_map F f.comm, },
  { intro P,
    ext,
    { simp only [functor_extension'_obj_p, functor.comp_map,
        functor_extension_obj_p, id_comp, eq_to_hom_refl, comp_id,
        to_karoubi_map_f], },
    refl, },
end

@[simp]
lemma to_karoubi_comp_functor_extension' (F : C ‚•§ karoubi D) :
  to_karoubi C ‚ãô functor_extension' F = F :=
begin
  apply functor.ext,
  { intros X Y f,
    ext,
    dsimp,
    simp only [karoubi.comp, karoubi.eq_to_hom_f, eq_to_hom_refl,
      to_karoubi_obj_p, functor_extension'_obj_p, comp_id],
    erw [F.map_id, karoubi.id_eq, ‚Üê (F.map f).comm], },
  { intro X,
    ext,
    { dsimp,
      erw F.map_id,
      simp only [id_comp, karoubi.id_eq, comp_id], },
    { refl, }, },
end

@[simp]
lemma to_karoubi_comp_functor_extension (F : C ‚•§ D) :
  to_karoubi C ‚ãô functor_extension F = F ‚ãô to_karoubi D :=
by rw [functor_extension_eq, to_karoubi_comp_functor_extension']

@[simps]
def functor_extension'' [is_idempotent_complete D]
  (F : C ‚•§ D) : karoubi C ‚•§ D :=
  functor_extension F ‚ãô (to_karoubi_is_equivalence D).inverse

/-
@[simps]
def functor_extension_hom_equiv {D : Type*} [category D] [preadditive D]
  (F G : C ‚•§ D) : (F ‚ü∂ G) ‚âÉ (functor_extension F ‚ü∂ functor_extension G) :=
{ to_fun := Œª œÜ,
  { app := Œª P,
    { f := F.map P.p ‚â´ œÜ.app P.X ‚â´ G.map P.p,
      comm := begin
        simp only [functor_extension_obj_p],
        slice_rhs 1 2 { rw [‚Üê F.map_comp, P.idempotence], },
        slice_rhs 3 4 { rw [‚Üê G.map_comp, P.idempotence], },
      end },
    naturality' := Œª P Q f, begin
      ext,
      simp only [functor_extension_map_f, comp, assoc, nat_trans.naturality_assoc],
      simp only [‚Üê G.map_comp, karoubi.p_comp, ‚Üê assoc, karoubi.comp_p],
    end },
  inv_fun := Œª œà,
  { app := Œª X, (œà.app ((to_karoubi C).obj X)).f,
    naturality' := Œª X Y f, hom_ext.mp (œà.naturality ((to_karoubi C).map f)), },
  left_inv := Œª œÜ, begin
    ext X,
    dsimp,
    simp only [functor.map_id, id_comp, comp_id],
  end,
  right_inv := Œª œà, begin
    ext1,
    ext1 P,
    exact (nat_trans_eq œà P).symm,
  end }

lemma functor_extension_hom_to_fun_comp {D : Type*} [category D] [preadditive D]
  {F G H : C ‚•§ D} (œÜ : F ‚ü∂ G) (œà : G ‚ü∂ H) :
  (functor_extension_hom_equiv F H).to_fun (œÜ ‚â´ œà) =
  (functor_extension_hom_equiv F G).to_fun œÜ ‚â´ (functor_extension_hom_equiv G H).to_fun œà :=
begin
  ext P,
  simp only [equiv.to_fun_as_coe, functor_extension_hom_equiv_apply_app_f, comp,
    assoc, nat_trans.naturality_assoc, nat_trans.comp_app, ‚Üê H.map_comp, P.idempotence],
end

lemma functor_extension_hom_to_fun_id {D : Type*} [category D] [preadditive D]
  {F : C ‚•§ D} :
  (functor_extension_hom_equiv F F).to_fun (ùüô F) = ùüô _ :=
begin
  ext P,
  simp only [equiv.to_fun_as_coe, functor_extension_hom_equiv_apply_app_f, id_eq,
    nat_trans.id_app, functor_extension_obj_p, id_comp, ‚Üê F.map_comp, P.idempotence],
end

lemma functor_extension_hom_inv_fun_comp {D : Type*} [category D] [preadditive D]
  {F G H : C ‚•§ D} (œÜ : functor_extension F ‚ü∂ functor_extension G) (œà : functor_extension G ‚ü∂ functor_extension H) :
  (functor_extension_hom_equiv F H).inv_fun (œÜ ‚â´ œà) =
  (functor_extension_hom_equiv F G).inv_fun œÜ ‚â´ (functor_extension_hom_equiv G H).inv_fun œà :=
begin
  ext X,
  simp only [comp, nat_trans.comp_app, equiv.inv_fun_as_coe,
    functor_extension_hom_equiv_symm_apply_app],
end

lemma functor_extension_hom_inv_fun_id {D : Type*} [category D] [preadditive D]
  {F : C ‚•§ D} :
  (functor_extension_hom_equiv F F).inv_fun (ùüô (functor_extension F)) = ùüô _ :=
begin
  ext X,
  simp only [to_karoubi_obj_p, id_eq, nat_trans.id_app, functor_extension_obj_p,
    equiv.inv_fun_as_coe, functor_extension_hom_equiv_symm_apply_app, F.map_id X],
end

@[simps]
def functor_extension_iso_equiv {D : Type*} [category D] [preadditive D]
  (F : C ‚•§ D) (G : C ‚•§ D) : (F ‚âÖ G) ‚âÉ (functor_extension F ‚âÖ functor_extension G) :=
{ to_fun := Œª œÜ,
  { hom := (functor_extension_hom_equiv F G).to_fun œÜ.hom,
    inv := (functor_extension_hom_equiv G F).to_fun œÜ.inv,
    hom_inv_id' := by rw [‚Üê functor_extension_hom_to_fun_comp, œÜ.hom_inv_id, functor_extension_hom_to_fun_id],
    inv_hom_id' := by rw [‚Üê functor_extension_hom_to_fun_comp, œÜ.inv_hom_id, functor_extension_hom_to_fun_id], },
  inv_fun := Œª œà,
  { hom := (functor_extension_hom_equiv F G).inv_fun œà.hom,
    inv := (functor_extension_hom_equiv G F).inv_fun œà.inv,
    hom_inv_id' := by rw [‚Üê functor_extension_hom_inv_fun_comp, œà.hom_inv_id, functor_extension_hom_inv_fun_id],
    inv_hom_id' := by rw [‚Üê functor_extension_hom_inv_fun_comp, œà.inv_hom_id, functor_extension_hom_inv_fun_id], },
  left_inv := Œª œÜ, by { ext1, exact (functor_extension_hom_equiv F G).left_inv œÜ.hom, },
  right_inv := Œª œà, by { ext1, exact (functor_extension_hom_equiv F G).right_inv œà.hom, }, }
-/

@[simps]
def to_karoubi_hom_equiv (F G : karoubi C ‚•§ D) :
  (F ‚ü∂ G) ‚âÉ (to_karoubi _ ‚ãô F ‚ü∂ to_karoubi _ ‚ãô G) :=
{ to_fun := Œª œÜ,
  { app := Œª X, œÜ.app ((to_karoubi C).obj X),
    naturality' := Œª X Y f, by simp only [nat_trans.naturality, functor.comp_map], },
  inv_fun := Œª œà,
  { app := Œª P, F.map (decomp_id_i P) ‚â´ (œà.app P.X) ‚â´ G.map (decomp_id_p P),
    naturality' := Œª P Q f, by {
      slice_lhs 1 2 { rw [‚Üê F.map_comp], },
      slice_rhs 3 4 { rw [‚Üê G.map_comp], },
      rw [decomp_id_i_naturality, decomp_id_p_naturality,
        F.map_comp, G.map_comp],
      slice_lhs 2 3 { erw œà.naturality, },
      simp only [assoc],
      refl, }, },
  left_inv := Œª œÜ, by { ext P, exact (nat_trans_eq œÜ P).symm, },
  right_inv := Œª œà, begin
    ext X,
    dsimp,
    erw [decomp_id_i_to_karoubi, decomp_id_p_to_karoubi,
      F.map_id, G.map_id, comp_id, id_comp],
  end }

lemma to_karoubi_hom_inv_fun_comp {F G H : karoubi C ‚•§ D}
  (œÜ : to_karoubi _ ‚ãô F ‚ü∂ to_karoubi _ ‚ãô G)
  (œà : to_karoubi _ ‚ãô G ‚ü∂ to_karoubi _ ‚ãô  H) :
  (to_karoubi_hom_equiv F H).inv_fun (œÜ ‚â´ œà) =
  (to_karoubi_hom_equiv F G).inv_fun œÜ ‚â´ (to_karoubi_hom_equiv G H).inv_fun œà :=
begin
  ext P,
  dsimp,
  slice_rhs 3 4 { rw [‚Üê G.map_comp, ‚Üê decomp_p], },
  erw œà.naturality P.p,
  slice_rhs 4 5 { erw [‚Üê H.map_comp], },
  simp only [assoc],
  congr,
  ext,
  simp only [decomp_id_p_f, comp, to_karoubi_map_f, P.idempotence],
end

lemma to_karoubi_hom_inv_fun_id
  {F : karoubi C ‚•§ D} :
  (to_karoubi_hom_equiv F F).inv_fun (ùüô _) = ùüô _ :=
begin
  ext P,
  simp only [to_karoubi_hom_equiv_symm_apply_app, nat_trans.id_app, equiv.inv_fun_as_coe],
  erw [id_comp, ‚Üê F.map_comp, ‚Üê decomp_id, F.map_id],
end

@[simps]
def to_karoubi_iso_equiv
  (F G : karoubi C ‚•§ D) : (F ‚âÖ G) ‚âÉ (to_karoubi _ ‚ãô F ‚âÖ to_karoubi _ ‚ãô G) :=
{ to_fun := Œª œÜ,
  { hom := (to_karoubi_hom_equiv F G).to_fun œÜ.hom,
    inv := (to_karoubi_hom_equiv G F).to_fun œÜ.inv, },
  inv_fun := Œª œà,
  { hom := (to_karoubi_hom_equiv F G).inv_fun œà.hom,
    inv := (to_karoubi_hom_equiv G F).inv_fun œà.inv,
    hom_inv_id' := by rw [‚Üê to_karoubi_hom_inv_fun_comp, iso.hom_inv_id, to_karoubi_hom_inv_fun_id],
    inv_hom_id' := by rw [‚Üê to_karoubi_hom_inv_fun_comp, iso.inv_hom_id, to_karoubi_hom_inv_fun_id], },
  left_inv := Œª œÜ, by { ext P, simp only [equiv.to_fun_as_coe, equiv.symm_apply_apply,
    equiv.inv_fun_as_coe], },
  right_inv := Œª œà, by { ext X, simp only [equiv.to_fun_as_coe, equiv.apply_symm_apply,
    equiv.inv_fun_as_coe], } }

end idempotents

end category_theory
